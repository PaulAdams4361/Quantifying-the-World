---
title: "Real-Time Indoor Location Positioning"
author: "Justin Howard, Paul Adams, and Stuart Miller"
date: September 8, 2020
lang: en-US
class: man
# figsintext: true
numbersections: true
encoding: UTF-8
bibliography: references.bib
biblio-style: apalike
output:
  bookdown::pdf_document2:
     citation_package: natbib
     keep_tex: true
     toc: false
header-includes:
   - \usepackage{amsmath}
   - \usepackage{gensymb}
   - \usepackage[utf8]{inputenc}
   - \usepackage[T1]{fontenc}
   - \usepackage{setspace}
   - \usepackage{hyperref}
   - \onehalfspacing
   - \newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
editor_options: 
  chunk_output_type: console
---

```{r, lib-read, results='hide', message=FALSE, include=FALSE, echo=FALSE}
# libraries
library(tidyverse)
library(caret)
source('./functions.R')

# set a random seed for repodicibility
set.seed(42)


# load the data
offline <- readData()
online <- readData(filename = './online.data.txt',
                   subMacs = unique(offline$mac))

macAddresses <- sort(unique(offline$mac))

# create a unique position identifier
offline$posXY <- paste(offline$posX, offline$posY, sep = '-')
online$posXY <- paste(online$posX, online$posY, sep = '-')
```

# Introduction


Real Time Location Systems (RTLS) that are capable of tracking business assets and people in special circumstances,
 are a popular area of research. 
Warehouse distribution and delivery services have grown more rapidly due to the COVID-19 pandemic,
 and with that growth, we can expect the relative importance of tracking assets at scale to increase.
In this case study, we assess whether it is possible to predict locations based on the measurement
 of WiFi signals from fixed access points (AP)\footnotemark.
Additionally, two APs are placed in close proximity, we assess the impact of using both of these APs.
The location sensing system analyzed in this case study is located in an indoor office environment
 on a single floor of a building.

\footnotetext{This analysis was conducted with the R programming language (\cite{R}).}

# Methods

## Data 

### Data Collection

The data was collected in an indoor office environment on a single floor with 7 fixed WiFi APs.
The WiFi APs are identifiable by their media-access-control (MAC) addresses.
It is shown by \cite{NolanLang} that two of these APs 
 (\texttt{00:0f:a3:39:e1:c0} and \texttt{00:0f:a3:39:dd:cd})
 are positioned in close proximity.
The experiment area was split into a grid 166 measurement points, which were spaced 1 meter apart.
The points of measurement are referred to as `posX` and `posY`.
Using a handheld WiFi scanning device, WiFi signal strength measurements were collected at each of the 166 locations.
Additionally, the handheld WiFi scanning device was rotated to 8 angles 
 (45\degree  increments from 0)
 at each measurement location.
The resulting dataset contains approximately one million measurements.

### Data Cleaning

The data are provided as measurement logs with the MAC address of the scanning device, 
 measurement position, measurement orientation, AP MAC address, AP signal strength,
 and timestamp on a single line.
We extracted the data by reading each line and tokenizing each unit of information.
The data was initially organized in a long format data frame with
 time, position X, Y, and Z, orientation, AP MAC address, signal strength, and channel as the columns.
Once the data was organized, we were able to determine that several columns were not necessary.
Specifically, we removed position Z and the scan MAC address because these were fixed throughout the experiment
 and channel because each AP used a single channel throughout the experiment.
We also found that several MAC addresses were coded as \textit{adhoc} (\texttt{type=1}).
These were removed since we are only interested in positioning based on the fixed APs (\texttt{type=3}).
Additionally, we determined that there some noise present in the orientation measurement.
The experiment specified that only 8 angles were considered (each 45\degree  increment from 0).
All orientation values were rouned to the nearest 45\degree increment.
Any missing signal values were filled with -100, imputing it as a very low strength signal.

 
```{r, echo=FALSE}
offline_pivot <- offline %>% 
   pivot_wider(names_from = mac,
               values_from = 'signal',
               values_fn = list(signal=mean))
offline_pivot[is.na(offline_pivot)] <- -100
```


## Modeling Method

We chose to model the position as a function of the WiFi singal strength with 
\textit{k}-nearest neighbors (\textit{k}-NN).
Intuitively, a \textit{k}-NN model will predict a new position as the average positions of the closest \textit{k}
 data points in the training data based on the WiFi signals.
Since the features are microwaves, which can pass through physical barriers,
 we used euclidean distance to determine the closest signals.
To use a \textit{k}-NN, the value of k most be estimated based on the training data.
We used 5-fold cross validation to determine the value of \textit{k},
 selecting the value of \textit{k} that produced the lowest error based on root meean squared error (RMSE).

An advantage of \textit{k}-NN is that it is non-parametric, thus it not necessary to assess whether the data
 exhibit certain distributional properties.
However, a potential disadvantage of \textit{k}-NN is the computational complexity,
 which is given by (\ref{eqn:knncomplexity}) for large $N$.
This time complexity means a \textit{k}-NN would not be suitable for modeling position in large areas as the number measurement points would be large.


\begin{equation}
\label{eqn:knncomplexity}
O\left(n\right) \sim \frac{n^2}{2}
\end{equation}



## Model Validation

(Describe how you estimated your error and found the best fit ASSUMING you CANNOT USE THE ONLINE DATA.)

kold cross validation 
Predicting the real-time X- and Y-coordinate positions using K-Nearest Neighbors required the constructing an ensemble model. The first
model we built contained all devices. The second model we built included all but the device excluding MAC address 00:0f:a3:39:dd:cd.
Finally, we developed a third model which did not include the device identified as 00:0f:a3:39:e1:c0. We made this comparison because
both of those explicitly mentioned devices were positioned at the same location within the study. We modeled along this process for both
X- and Y-coordinate location prediction sets.

As mentioned below, we obtained the lowest measures of error for positions X by setting \texttt{k} to 4 and positions Y by settting
\texttt{k} to 5. However, this was derived for internal-cross validation. In order to simulate a measure of error that could be expected
after applying to the data once the system is online (online data set), we applied cross-validation to a holdout data set, comprised of
25% of the offline data set. For this analysis, we trained the offline data set on 75%. Because there was a holdout of 25%, we applied
repeated cross-validation to build the models, using 5 folds with each of the 15 repeats to prevent model training information loss.

```{r, Hold-Out Testing for Online Error Simulation, results='hide', message=FALSE, include=FALSE, echo=FALSE}
###########################################
############# Prepare Offline
###########################################
sapply(offline_pivot, class)
offline_pivot$time = as.double(offline_pivot$time)
offline_pivot$posX = as.double(offline_pivot$posX)
offline_pivot$posY = as.double(offline_pivot$posY)
offline_pivot$posZ = as.double(offline_pivot$posZ)
offline_pivot$orientation = as.double(offline_pivot$orientation)
offline_pivot$type = as.double(offline_pivot$type)
sapply(offline_pivot, class)

#offline_pivot = subset(offline_pivot, select = -c(nas))

###########################################
############# Prepare Online
###########################################
sapply(online_pivot, class)
online_pivot$time = as.double(online_pivot$time)
online_pivot$posX = as.double(online_pivot$posX)
online_pivot$posY = as.double(online_pivot$posY)
online_pivot$posZ = as.double(online_pivot$posZ)
online_pivot$orientation = as.double(online_pivot$orientation)
online_pivot$type = as.double(online_pivot$type)
sapply(online_pivot, class)

# 75/25 train/test split:
offline_train_75 = offline_pivot[1:floor((dim(offline_pivot)[[1]]*0.75)),] #686,213 training samples
offline_test_25 = offline_pivot[ceiling((dim(offline_pivot)[[1]]*0.75)):dim(offline_pivot)[[1]],] # 228, 738 testing samples

offline_train_subset <- offline_train_75 %>% filter(orientation < 135-4 & orientation < 135+4)


                                                        #XXXXXXXXXXXXXXXXXXX#
                                                        #XXXXXXXXXXXXXXXXXXX#
                                                        #  Building for X   #
                                                        #XXXXXXXXXXXXXXXXXXX#
                                                        #XXXXXXXXXXXXXXXXXXX#

trainContrl <- trainControl(method="repeatedcv", repeats = 15, number = 5)
#knn.grid <- expand.grid(k = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
knn.grid <- expand.grid(k = seq(1:15))

knn_fit.posX.allMAC <- train(posX ~ .
                             , data=subset(offline_train_subset, select = -c(time, posY, posZ, type))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )


########## End of using all MACs

knn_fit.posX.c0MAC <- train(posX ~ .
                             , data=subset(offline_train_subset, select = -c(time, posY, posZ, `00:0f:a3:39:dd:cd`))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )

########## End of using MAC c0

knn_fit.posX.cdMAC <- train(posX ~ .
                             , data=subset(offline_train_subset, select = -c(time, posY, posZ,`00:0f:a3:39:e1:c0`))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )
                             
########## End of using MAC cd


                                                        #YYYYYYYYYYYYYYYYYYY#
                                                        #YYYYYYYYYYYYYYYYYYY#
                                                        #  Building for Y   #
                                                        #YYYYYYYYYYYYYYYYYYY#
                                                        #YYYYYYYYYYYYYYYYYYY#

knn_fit.posY.allMAC <- train(posY ~ .
                             , data=subset(offline_train_subset, select = -c(time, posX, posZ, type))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )

########## End of using all MACs

knn_fit.posY.c0MAC <- train(posY ~ .
                             , data=subset(offline_train_subset, select = -c(time, posX, posZ, `00:0f:a3:39:dd:cd`))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )

########## End of using MAC c0

knn_fit.posY.cdMAC <- train(posY ~ .
                             , data=subset(offline_train_subset, select = -c(time, posX, posZ,`00:0f:a3:39:e1:c0`))
                             , method = "knn"
                             , trControl=trainContrl
                             , metric = "RMSE"
                             , tuneGrid = knn.grid # instead of tuneLength = 5 different values of k
                             )
                             
########## End of using MAC cd

X_preds.allMAC <- predict(knn_fit.posX.allMAC, newdata = subset(offline_test, select = -c(time, posY, posZ)))
Y_preds.allMAC <- predict(knn_fit.posY.allMAC, newdata = subset(offline_test, select = -c(time, posX, posZ)))

X_res = data.frame(X_preds.allMAC, offline_test$posX)
Y_res = data.frame(Y_preds.allMAC, offline_test$posY)
names(X_res) <- c('preds','actuals')
names(Y_res) <- c('preds','actuals')
X_res$residuals = X_res$preds - X_res$actuals
Y_res$residuals = Y_res$preds - Y_res$actuals

X_RSS <- c(crossprod(X_res$residuals))
X_MSE <- X_RSS / length(X_res$residuals)
X_RMSE <- sqrt(X_MSE)

Y_RSS <- c(crossprod(Y_res$residuals))
Y_MSE <- Y_RSS / length(Y_res$residuals)
Y_RMSE <- sqrt(Y_MSE)

comboRMSE <- sqrt(X_MSE + Y_MSE)
comboRMSE
```
The estimated Root Mean Square Error for the ensemble model applied to the online data set is roughly 7.638. We derived this value by
taking the mean squared error for the residual values on the holdout sets for both the predicted X positions and predicted Y positions.
The model estimating positions Y outperformed the model estimated positions X by RMSE of 1.823 to 7.418, respectively.

| Positional Predictions           | Root Mean Squared Error | 
|----------------------------------|-------------------------|
| Predicted X                      | 7.418                   |
| Predicted Y                      | 1.823                   |
| Online X-Y Ensemble Predictions  | 7.638                   |



```{r, echo=FALSE}

offline_subset <- select(offline_pivot, c("posX", "posY", 'posXY', "angle",
                                    "00:14:bf:b1:97:8a", "00:14:bf:b1:97:90", "00:0f:a3:39:e1:c0",
                                    "00:14:bf:b1:97:8d", "00:14:bf:b1:97:81", "00:14:bf:3b:c7:c6",
                                    "00:0f:a3:39:dd:cd"))

offline_subset <- offline_subset %>% filter(angle > 135 - 4 & angle < 135 + 4)


knn.grid <- expand.grid(k = seq(1:15))

train.control <- trainControl(method = 'cv', number = 5)

# fit a model for posX with AP c0
model.c0.x <- train(
   posX ~ . ,
   data = offline_subset %>% select(-c("posY","posXY", "00:0f:a3:39:dd:cd")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

# fit a model for posY with AP c0
model.c0.y <- train(
   posY ~ . ,
   data = offline_subset %>% select(-c("posX","posXY", "00:0f:a3:39:dd:cd")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

# fit a model for posX with AP cd
model.cd.x <- train(
   posX ~ . ,
   data = offline_subset %>% select(-c("posY","posXY", "00:0f:a3:39:e1:c0")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

# fit a model for posY with AP cd
model.cd.y <- train(
   posY ~ . ,
   data = offline_subset %>% select(-c("posX","posXY", "00:0f:a3:39:e1:c0")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

# fit a model for posX with all APs
model.all.x <- train(
   posX ~ . ,
   data = offline_subset %>% select(-c("posY","posXY")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

# fit a model for posY with all APs
model.all.y <- train(
   posY ~ . ,
   data = offline_subset %>% select(-c("posX","posXY")),
   method = 'knn',
   trControl = train.control,
   tuneGrid = knn.grid
)

errors <- data.frame(
   k = rep(model.all.y$results$k, 3),
   model = c(
      rep('All APs', length(model.all.y$results$k)),
      rep('AP-c0', length(model.all.y$results$k)),
      rep('AP-cd', length(model.all.y$results$k))),
   error = c(model.all.y$results$RMSE^2 + model.all.x$results$RMSE^2,
                 model.c0.y$results$RMSE^2 + model.c0.x$results$RMSE^2,
                 model.cd.y$results$RMSE^2 + model.cd.x$results$RMSE^2)
)

```

# Results

As shown in Fig. 1, we found that \texttt{k} of 4 or 5 minimized the RMSE of all three models.
Based the CV results, 4 was chosen as the value of \texttt{k} for the \texttt{k}-NN model.

```{r, echo=FALSE}
errors %>%
   ggplot(aes(x = k, y = error, color = model)) +
   geom_line() + 
   xlab('k Neighbors') +
   ylab('RMSE') +
   ggtitle('RMSE of Models with 5-fold CV Over k') +
   labs(caption = paste(
      'Figure 1:',
      'The mean RMSE of 5-fold cross validation for k-NN models using all APs (All APs),',
      'all APs excluding 00:0f:a3:39:dd:cd (AP-c0),\n',
      'and all APs excluding 00:0f:a3:39:e1:c0 (AP-cd) for k values 1 through 15.')
      ) +
   theme(
      plot.title = element_text(hjust = 0.5),
      plot.caption = element_text(hjust = 0)
  )
```


**What about using them both?**


* There are 2 macIDs located at the same position.  
* Does one give better performance than the other?
* (00:0f:a3:39:e1:c0, 00:0f:a3:39:dd:cd)


Use c0, then use cd, than use cd and c0

a plot with all three models

| AP Feature Set         | Mean Squared Error | 
|------------------------|--------------------|
| Excluding \texttt{00:0f:a3:39:dd:cd}  | XX                 |
| Excluding \texttt{00:0f:a3:39:e1:c0}  | XX                 |
| All APs                | XX                 |






# Conclusion

(What is the drawback (if any of using this method to real-time locate an object)?)

KNN is slow. calculation scales as n^2/2. Considers the whole dataset.

Describe a method that may be an improvement based on your perceived drawbacks.

Linear regression, assuming the assumptions are met

* Variance of the residuals is constant
* Normally distributed residuals
* No outlier + leverage points

Given that electromagnetic signals fall off as $1/r^2$, we could potentionally use polynomial regression.

\newpage

\appendix

# Code

The code used to produce the analysis in shown below.

```

#' Process a single line of the data files.
#'
#' @description
#' Produces a list of matricies from a data line.
#' The columns are as follows:
#' time, scanMAC, positionX, positionY, positionZ,
#' orientation, MAC, signalRSSI, channel, router_type
#'
#' @param x A file line
#'
processLine = function(x)
{
  # tokenize line on delimiters ;=,
  tokens = strsplit(x, "[;=,]")[[1]]
  # return null when there are no measurements
  if (length(tokens) == 10) 
    return(NULL)
  # get matrix of measured RSSI
  tmp = matrix(tokens[ - (1:10) ], , 4, byrow = TRUE)
  # add handheld device data and return resulting matrix
  cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), 6, 
               byrow = TRUE), tmp)
}

#' Round the measurement angle to the nearest 45 deg.
#'
#' @param angles a vector of angles; expected 0 - 360
#'
roundOrientation = function(angles) 
  {
  # create a sequence of reference angles
  # 0, 45, 90, ... , 315
  refs = seq(0, by = 45, length  = 9)
  # round angles to the closest reference value
  q = sapply(angles, function(o) which.min(abs(o - refs)))
  c(refs[1:8], 0)[q]
}


#' Load data files for this case study.
#' 
#' @description
#' Produces a data.frame with the following columns
#' "time", "posX", "posY", "orientation", "mac", "signal",
#' "rawTime", "angle"
#' 
#' Only regular access points are kept (router_type==3).
#' Time is converted from milliseconds to seconds.
#' 
#'
#' @param filename The path to the data file
#' @param subMacs A vector of MAC addresses to use in the data
#'
readData = 
  function(filename = './offline.data.txt', 
           subMacs = c("00:0f:a3:39:e1:c0", "00:0f:a3:39:dd:cd", "00:14:bf:b1:97:8a",
                       "00:14:bf:3b:c7:c6", "00:14:bf:b1:97:90", "00:14:bf:b1:97:8d",
                       "00:14:bf:b1:97:81"))
  {
    txt <- readLines(filename)
    lines <- txt[ substr(txt, 1, 1) != "#" ]
    tmp <- lapply(lines, processLine)
    offline <- as.data.frame(do.call("rbind", tmp), 
                             stringsAsFactors= FALSE) 
    
    names(offline) <- c("time", "scanMac", 
                        "posX", "posY", "posZ", "orientation", 
                        "mac", "signal", "channel", "type")
    
    # keep only signals from access points
    offline <- offline[ offline$type == "3", ]
    
    # drop scanMac, posZ, channel, and type - no info in them
    dropVars <- c("scanMac", "posZ", "channel", "type")
    offline <- offline[ , !( names(offline) %in% dropVars ) ]
    
    # drop more unwanted access points
    offline <- offline[ offline$mac %in% subMacs, ]
    
    # convert numeric values
    numVars <- c("time", "posX", "posY", "orientation", "signal")
    offline[ numVars ] <- lapply(offline[ numVars ], as.numeric)
    
    # convert time to POSIX
    offline$rawTime <- offline$time
    offline$time <- offline$time/1000
    class(offline$time) <- c("POSIXt", "POSIXct")
    
    # round orientations to nearest 45
    offline$angle = roundOrientation(offline$orientation)
    
    return(offline)
  }

```


